package xyz.mystikolabs.tuneit;

import android.media.AudioFormat;
import android.media.AudioManager;
import android.media.AudioTrack;
import android.os.Build;

/**
 * Created by nikhya on 17/9/17.
 * <p>
 * Plays the tone on a thread
 */

public class RunToneProcess extends Thread {

    private boolean isPlaying = false;
    private AudioTrack audioTrack = null;
    private final int duration;
    private final int toneFrequency;
    private float volume = 0f;

    private StopToneListener stopToneListener;

    public RunToneProcess(int duration, int toneFrequency, float volume, StopToneListener stopToneListener) {
        this.duration = duration;
        this.toneFrequency = toneFrequency;
        this.volume = volume;
        this.stopToneListener = stopToneListener;
    }


    @Override
    public void run() {
        super.run();


        startPlaying();
    }


    //start playing the tone
    private void startPlaying() {

        if (!isPlaying) {
            isPlaying = true;

            //the sample rate of 44.1 KHz
            int rate = 44100;

            double sample = (double) duration * rate;
            sample = Math.ceil(sample);
            int intSample = (int) sample;

            //this is the array to store our samples of tones
            double[] exactSample = new double[intSample];


            //generating PCM according to bytes
            /*
            * PCM stands for Pulse Code Modulation
            *Each analog signal is represented digitally
            *i.e. method to convert analog signal to digital signal
            * Each value of the sample can be represented by 8 or 16 bytes
            * */
            byte[] generated = new byte[2 * intSample];


            /*
            *The sound can be generated by using simple sin wave function
            * You can check https://en.wikipedia.org/wiki/Sine_wave
            **/
            //The sample is filled in an array to create a byte PCM array

            for (int i = 0; i < intSample; i++) {

                exactSample[i] = Math.sin(toneFrequency * 2 * Math.PI * i / (rate));

            }


            /*
            There might be over tuning of the sound in android to
            minimize that some care taking things to get clear sound
             */

            int buffer = 0;
            int k;

            /*
            *The range of amplitude as a percent of sample count
            **/
            int range = intSample / 20;


            /*
            *when the sound starts playing the
            * low to high pitch needs to be handled
            * in case of 16 bit PCM
            **/
            //when sound starts from low
            for (k=0;k<range;k++){
                final short seg = (short)(exactSample[k]*32767*k/range);
                generated[buffer++] = (byte) (seg & 0x00ff);
                generated[buffer++] = (byte) ((seg & 0xff00) >>> 8);
            }

            //when sound is at peak i.e. Max amplitude
            for (k = range; k<intSample-range; k++){
                final short seg = (short)(exactSample[k]*32767);
                generated[buffer++] = (byte) (seg & 0x00ff);
                generated[buffer++] = (byte) ((seg & 0xff00) >>> 8);
            }

            //when sound is down to low or zero
            for (k = intSample-range; k<intSample; k++){
                final short seg = (short)(exactSample[k]*32767*(intSample-k)/range);
                generated[buffer++] = (byte) (seg & 0x00ff);
                generated[buffer++] = (byte) ((seg & 0xff00) >>> 8);
            }


            /*
            * Now let's play the track using AudioTrack class
            * By providing our sample tone to it
            **/
            letsPlayTrack(rate,intSample,generated);


        }


    }



    private void letsPlayTrack(int rate,int intSample,byte[] generated){

            /*Now here we are using
            16 bti PCM which is pretty good than 8 bit PCM
            The simple difference between 16bit PCM and 8 bit PCM is that :
            8 bit PCM sounds like tunes of 80's which we used to hear in brick games and video games
            16 bit PCM is little bit modern even you can listen pure octave from this which is generally used in .WAV ringtone/ sound files
             */

        //here we are using 16 bit PCM as mentioned early

        try {

            int size = AudioTrack.getMinBufferSize(rate, AudioFormat.CHANNEL_OUT_MONO,AudioFormat.ENCODING_PCM_16BIT);
            audioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, rate, AudioFormat.CHANNEL_OUT_MONO, AudioFormat.ENCODING_PCM_16BIT, size, AudioTrack.MODE_STREAM);

            audioTrack.setNotificationMarkerPosition(intSample);
            audioTrack.setPlaybackPositionUpdateListener(new AudioTrack.OnPlaybackPositionUpdateListener() {
                @Override
                public void onMarkerReached(AudioTrack audioTrack) {


                    //stopping the track here
                    //TODO:Stop playing track
                    stopToneListener.onTrackStopped();
                }

                @Override
                public void onPeriodicNotification(AudioTrack audioTrack) {



                }
            });


            /*
            *checking volume
            **/

            float actualVolume = AudioTrack.getMaxVolume();
            if (volume>actualVolume){
                volume = actualVolume;
            }else if (volume<0){
                volume = 0;
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                audioTrack.setVolume(volume);
            }else{
                audioTrack.setStereoVolume(volume,volume);
            }

            /*
            *let's play track
            * but set the volume before playing the track
            * now call the write method to load the track and game on!
             */
            audioTrack.play();
            audioTrack.write(generated,0,generated.length);



        }catch (Exception e){

            e.printStackTrace();

        }
        stopPlaying();

    }


    /*
    stop playing the track by calling stop() method and free the audio player from
    current track
     */
    public void stopPlaying(){
        if (audioTrack != null && audioTrack.getState() == AudioTrack.PLAYSTATE_PLAYING) {
            audioTrack.stop();
            audioTrack.release();
            isPlaying = false;
        }
    }






}
